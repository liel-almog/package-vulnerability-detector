import { Injectable } from '@nestjs/common';
import semver from 'semver';
import {
  INVALID_DEFINITION_FILE,
  INVALID_OPERATION,
  INVALID_PACKAGE_MANAGER,
  INVALID_VERSION,
} from '../constants/error.constant.js';
import {
  DetectPackageVulnerabilities,
  GithubApiService,
} from '../github-api/github-api.service.js';
import { Ecosystem } from '../models/ecosystem.model.js';
import { StringToPackageJsonSchema } from '../scan/dto/scan.dto.js';
import { versionsOperations } from './models/package-versions.model.js';
import { VulnerablePackage } from './models/vulnerablePackage.type.js';

@Injectable()
export class VulnerabilitiesDetectorService {
  constructor(private readonly githubAPI: GithubApiService) {}

  async detectVulnerabilities(
    ecosystem: Ecosystem,
    definitionFile: string,
  ): Promise<VulnerablePackage[]> {
    const dependencies = this.convertDefinitionFileToDependencies(
      ecosystem,
      definitionFile,
    );

    // If there are no dependencies, return an empty array
    if (!Object.keys(dependencies).length) {
      return [];
    }

    const packagesVulnerabilities =
      await this.githubAPI.securityVulnerabilities(ecosystem, dependencies);

    // Flatten array of vulnerabilities
    const vulnerabilities = Object.values(packagesVulnerabilities)
      .map((vulnerabilitiesInPackage) => {
        return vulnerabilitiesInPackage.nodes;
      })
      .flat();

    // Remove vulnerabilities that are not within the range of the package version
    const vulnerabilitiesWithingRange = vulnerabilities.filter(
      (vulnerability) => {
        const { version } = dependencies[vulnerability.package.name]!;

        return this.isPackageVulnerable(
          version,
          vulnerability.vulnerableVersionRange,
        );
      },
    );

    // Return the vulnerable packages in a specific format
    return vulnerabilitiesWithingRange.map((vulnerability) => ({
      name: vulnerability.package.name,
      severity: vulnerability.severity,
      firstPatchedVersion: vulnerability.firstPatchedVersion.identifier,
      version: dependencies[vulnerability.package.name]!.version,
    }));
  }

  private isPackageVulnerable(
    packageVersion: string,
    vulnerabilityVersionRange: string,
  ) {
    const parts = vulnerabilityVersionRange.split(', ');

    for (const part of parts) {
      const [operation, version] = part.split(' ');
      const isValidVersion = semver.valid(version);
      const isValidOperation = versionsOperations.includes(operation as any);

      if (!isValidVersion || !version) {
        throw new Error(INVALID_VERSION);
      }

      if (!isValidOperation) {
        throw new Error(INVALID_OPERATION);
      }

      switch (operation) {
        case '>=':
          if (!semver.gte(packageVersion, version)) return false;
          break;
        case '<':
          if (!semver.lt(packageVersion, version)) return false;
          break;
        case '<=':
          if (!semver.lte(packageVersion, version)) return false;
          break;
        case '=':
          if (!semver.eq(packageVersion, version)) return false;
          break;
        default:
          throw new Error(INVALID_OPERATION);
      }
    }

    return true;
  }

  private convertDefinitionFileToDependencies(
    ecosystem: Ecosystem,
    definitionFile: string,
  ): DetectPackageVulnerabilities {
    switch (ecosystem) {
      case 'NPM':
        return this.npm(definitionFile);
      default:
        throw new Error(INVALID_PACKAGE_MANAGER);
    }
  }

  private npm(definitionFile: string): DetectPackageVulnerabilities {
    const packageJsonWithDependencies =
      StringToPackageJsonSchema.safeParse(definitionFile);

    if (!packageJsonWithDependencies.success) {
      throw new Error(INVALID_DEFINITION_FILE);
    }

    const { dependencies } = packageJsonWithDependencies.data;

    if (!dependencies) {
      return {};
    }

    return Object.entries(dependencies).reduce((acc, [name, version]) => {
      acc[name] = { name: name, version: version };
      return acc;
    }, {} as DetectPackageVulnerabilities);
  }
}
